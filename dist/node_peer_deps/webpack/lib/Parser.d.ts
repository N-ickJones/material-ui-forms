export = Parser;
declare const Parser_base: typeof import("../../tapable/lib/Tapable");
declare class Parser extends Parser_base {
    static parse(code: any, options: any): acorn.Node | undefined;
    constructor(options: any, sourceType?: string);
    hooks: {
        evaluateTypeof: import("../../tapable/lib/HookMap");
        evaluate: import("../../tapable/lib/HookMap");
        evaluateIdentifier: import("../../tapable/lib/HookMap");
        evaluateDefinedIdentifier: import("../../tapable/lib/HookMap");
        evaluateCallExpressionMember: import("../../tapable/lib/HookMap");
        statement: import("../../tapable/lib/SyncBailHook");
        statementIf: import("../../tapable/lib/SyncBailHook");
        label: import("../../tapable/lib/HookMap");
        import: import("../../tapable/lib/SyncBailHook");
        importSpecifier: import("../../tapable/lib/SyncBailHook");
        export: import("../../tapable/lib/SyncBailHook");
        exportImport: import("../../tapable/lib/SyncBailHook");
        exportDeclaration: import("../../tapable/lib/SyncBailHook");
        exportExpression: import("../../tapable/lib/SyncBailHook");
        exportSpecifier: import("../../tapable/lib/SyncBailHook");
        exportImportSpecifier: import("../../tapable/lib/SyncBailHook");
        varDeclaration: import("../../tapable/lib/HookMap");
        varDeclarationLet: import("../../tapable/lib/HookMap");
        varDeclarationConst: import("../../tapable/lib/HookMap");
        varDeclarationVar: import("../../tapable/lib/HookMap");
        canRename: import("../../tapable/lib/HookMap");
        rename: import("../../tapable/lib/HookMap");
        assigned: import("../../tapable/lib/HookMap");
        assign: import("../../tapable/lib/HookMap");
        typeof: import("../../tapable/lib/HookMap");
        importCall: import("../../tapable/lib/SyncBailHook");
        call: import("../../tapable/lib/HookMap");
        callAnyMember: import("../../tapable/lib/HookMap");
        new: import("../../tapable/lib/HookMap");
        expression: import("../../tapable/lib/HookMap");
        expressionAnyMember: import("../../tapable/lib/HookMap");
        expressionConditionalOperator: import("../../tapable/lib/SyncBailHook");
        expressionLogicalOperator: import("../../tapable/lib/SyncBailHook");
        program: import("../../tapable/lib/SyncBailHook");
    };
    options: any;
    sourceType: string;
    scope: any;
    state: any;
    comments: any;
    initializeEvaluating(): void;
    getRenameIdentifier(expr: any): any;
    walkClass(classy: any): void;
    walkMethodDefinition(methodDefinition: any): void;
    prewalkStatements(statements: any): void;
    blockPrewalkStatements(statements: any): void;
    walkStatements(statements: any): void;
    prewalkStatement(statement: any): void;
    blockPrewalkStatement(statement: any): void;
    walkStatement(statement: any): void;
    prewalkBlockStatement(statement: any): void;
    walkBlockStatement(statement: any): void;
    walkExpressionStatement(statement: any): void;
    prewalkIfStatement(statement: any): void;
    walkIfStatement(statement: any): void;
    prewalkLabeledStatement(statement: any): void;
    walkLabeledStatement(statement: any): void;
    prewalkWithStatement(statement: any): void;
    walkWithStatement(statement: any): void;
    prewalkSwitchStatement(statement: any): void;
    walkSwitchStatement(statement: any): void;
    walkTerminatingStatement(statement: any): void;
    walkReturnStatement(statement: any): void;
    walkThrowStatement(statement: any): void;
    prewalkTryStatement(statement: any): void;
    walkTryStatement(statement: any): void;
    prewalkWhileStatement(statement: any): void;
    walkWhileStatement(statement: any): void;
    prewalkDoWhileStatement(statement: any): void;
    walkDoWhileStatement(statement: any): void;
    prewalkForStatement(statement: any): void;
    walkForStatement(statement: any): void;
    prewalkForInStatement(statement: any): void;
    walkForInStatement(statement: any): void;
    prewalkForOfStatement(statement: any): void;
    walkForOfStatement(statement: any): void;
    prewalkFunctionDeclaration(statement: any): void;
    walkFunctionDeclaration(statement: any): void;
    prewalkImportDeclaration(statement: any): void;
    enterDeclaration(declaration: any, onIdent: any): void;
    blockPrewalkExportNamedDeclaration(statement: any): void;
    prewalkExportNamedDeclaration(statement: any): void;
    walkExportNamedDeclaration(statement: any): void;
    blockPrewalkExportDefaultDeclaration(statement: any): void;
    prewalkExportDefaultDeclaration(statement: any): void;
    walkExportDefaultDeclaration(statement: any): void;
    prewalkExportAllDeclaration(statement: any): void;
    prewalkVariableDeclaration(statement: any): void;
    blockPrewalkVariableDeclaration(statement: any): void;
    _prewalkVariableDeclaration(statement: any, hookMap: any): void;
    walkVariableDeclaration(statement: any): void;
    blockPrewalkClassDeclaration(statement: any): void;
    walkClassDeclaration(statement: any): void;
    prewalkSwitchCases(switchCases: any): void;
    walkSwitchCases(switchCases: any): void;
    walkCatchClause(catchClause: any): void;
    walkPattern(pattern: any): void;
    walkAssignmentPattern(pattern: any): void;
    walkObjectPattern(pattern: any): void;
    walkArrayPattern(pattern: any): void;
    walkRestElement(pattern: any): void;
    walkExpressions(expressions: any): void;
    walkExpression(expression: any): void;
    walkAwaitExpression(expression: any): void;
    walkArrayExpression(expression: any): void;
    walkSpreadElement(expression: any): void;
    walkObjectExpression(expression: any): void;
    walkFunctionExpression(expression: any): void;
    walkArrowFunctionExpression(expression: any): void;
    walkSequenceExpression(expression: any): void;
    walkUpdateExpression(expression: any): void;
    walkUnaryExpression(expression: any): void;
    walkLeftRightExpression(expression: any): void;
    walkBinaryExpression(expression: any): void;
    walkLogicalExpression(expression: any): void;
    walkAssignmentExpression(expression: any): void;
    walkConditionalExpression(expression: any): void;
    walkNewExpression(expression: any, ...args: any[]): void;
    walkYieldExpression(expression: any): void;
    walkTemplateLiteral(expression: any): void;
    walkTaggedTemplateExpression(expression: any): void;
    walkClassExpression(expression: any): void;
    _walkIIFE(functionExpression: any, options: any, currentThis: any): void;
    walkCallExpression(expression: any, ...args: any[]): void;
    walkMemberExpression(expression: any): void;
    walkThisExpression(expression: any): void;
    walkIdentifier(expression: any): void;
    /**
     * @deprecated
     * @param {any} params scope params
     * @param {function(): void} fn inner function
     * @returns {void}
     */
    inScope(params: any, fn: () => void): void;
    inFunctionScope(hasThis: any, params: any, fn: any): void;
    inBlockScope(fn: any): void;
    detectStrictMode(statements: any): void;
    detectMode(statements: any): void;
    enterPatterns(patterns: any, onIdent: any): void;
    enterPattern(pattern: any, onIdent: any): void;
    enterIdentifier(pattern: any, onIdent: any): void;
    enterObjectPattern(pattern: any, onIdent: any): void;
    enterArrayPattern(pattern: any, onIdent: any): void;
    enterRestElement(pattern: any, onIdent: any): void;
    enterAssignmentPattern(pattern: any, onIdent: any): void;
    evaluateExpression(expression: any): any;
    parseString(expression: any): any;
    parseCalculatedString(expression: any): any;
    parse(source: any, initialState: any): any;
    evaluate(source: any): any;
    getComments(range: any): any;
    parseCommentOptions(range: any): {
        options: null;
        errors: null;
    } | {
        options: {};
        errors: any[];
    };
    getNameForExpression(expression: any): {
        name: any;
        nameGeneral: string;
        free: any;
    } | null;
    readonly getCommentOptions: any;
}
